# aceflex

Some remarks beforehand:
- Here, I confine myself to explain the aims and elements of the function on a very basic level. If you want more information, please write me a mail or find a more detailed explanation [here](https://mirkoruks.github.io/).
- It's still a **beta** version. So if you find some bugs or have any comments, questions or suggestions, I am happy if you send me a mail to mirko.ruks@uni-bielefeld.de

`aceflex` is a function for flexible twin modeling. It is a wrapper for [OpenMx](https://openmx.ssri.psu.edu/), a very powerful and flexible package to calculate structural equation models. However, flexibility is somewhat positively correlated with complexity and defining the model using matrix algebra might be a high hurdle if you only want to estimate a simple univariate or multivariate model. So, the aim of `twinflex` is to reduce the complexity of the modeling proces while maintaining as much as possible the flexibility. The idea of `twinflex` is to produce a baseline model which you then can adjust according your own needs using by fixing free parameter and/or setting free fixed parameters using the `omxSetParameters` function of the OpenMx package. So, in the multivariate case, `twinflex` may estimate a model with a lot of parameters you are actually not interested in. In this case, just use `omxSetParameters` so adjust the model - you can control the model fitting process doing some LR-tests if needed. 

At the moment you can use the function to estimate univariate or multivariate ACE-models, controlling for covariates in the covariance matrix or in the mean vector. The default parametrization of the multivariate ACE models is the Cholesky parametrization, which assumes some causal or temporal order of the decomposed variables (see [Loehlin 1996](https://doi.org/10.1007/BF02361160) for a discussion of mathematically equivalent multivariate ACE models). There are other parametrizations, like the "correlated factor" (CF) or the "variance component" (VC) approach. In both parametrizations, there are no "cross-paths" (effects from the ACE component of one Variable on another variable). Instead, common genetic and environmental influences are defined via the correlation (CF) or the covariance (VC) between the ACE factors. All these three approaches don't include phenotypic effects of the decomposed variables, but assume that their covariance can be explained by common ACE components. [Kohler et al. (2011)](https://doi.org/10.1080/19485565.2011.580619) discuss another approach which allows to estimate a phenotypic effect with the identifying assumption of no non-shared environmental confounding, the ACE beta model, which allows to estimate the phenotytpic effect controlling for genetic and shared environmental confounding just like in FE regression with MZ twins, but unlike the FE regressions with MZ twins includes the confounders into the model and, thus, allows to investigate the genetic and environmental structure of the confounding. At the moment, you can use the Cholesky or the Kohler approach with `twinflex`. The implementation of the CF and VC model is planned - but not very soon.

Regarding the scale of the decomposed variables, there are no constraints! You can decompose continuous variables or categorical (that is: ordinal or dichotomous) variables. For the categorical variables, the functions estimates a liability threshold model which assumes that the categorical variables are "imperfect" measures of a true, underlying liability/risk/propensity. This liability is not observed and is considered as a latent factor. For dichotomous variable, the scale of this underlying latent variable is fixed to 1 and the mean to 0, while the threshold is estimated. For variables with three or more categories, the function follows the approach discussed by [Mehta et al. (2004)](https://doi.org/10.1037/1082-989x.9.3.301) and constrains the first two thresholds allowing to estimate the variance and mean of the underlying latent variable. At the moment, the covariates are exogenous variables, so there is no need to estimate a liability threshold model for them. If some of your covariates are not continuous, you can recode them to dichotomous variables and enter them into the model.

Here is the complete function with its argument, including their default values (if defined):
<pre><code>
twinflex(acevars, data, zyg, sep, covvars=NULL, covariance = TRUE, ordinal = NULL, optimizer = "SLSQP", tryHard = FALSE, type = "chol")
</code></pre>

Some information about the arguments:
- `acevars`: a vector of strings, like e.g. `c("extraversion", "education")`, with the variables that you want to use for the ACE decomposition. It is important that you enter the variables without the twin specific suffix (see the argument `sep`).
  - Regarding the multivariate case: The Cholesky parametrization assumes a causal or temporal order. The first variable in the acevars vector is considered to be the first in this causal or temporary sense as well; the second variable as the second and so on. So have in mind to check the order of your variables in the multivariate case. 
- `data`: It's the data frame
- `zyg`: A string element with the name of the variable with the zygosity information. Note, that I assume that 1 means MZ and 2 means DZ, so make sure that you recode the zygosity variable accordingly.
- `sep`: In the `acevars` argument you have to enter the variables without the twin-specific suffix. So instead of `c("iqt1","iqt2)`, it's `c("iq")` and the separator can be entered as a string in the sep argument (`sep = "t"` in this case). If the variable names are instead `"iq_1"` and `"iq_2"`, you may enter `sep = "_"`
- `covvars`: Here you can enter the covariates. Like for the acevars, you must not enter the variables with the twin specific suffix. You can enter variables with or without within-twin-pair variance. The function checks if there is within-pair variance automatically. The default is `covvars = NULL`, so if you don't enter covariates, the function assumes that there are none. 
- `covariance`: Here you can define if you want to enter the covariates in the covariance matrix or as "definition variables" in the means vector.
- `ordinal`: It is a vector of strings specifying which of the elements of `acevars` are ordinal variables. If you want to decompose extraversion and education in a multivariate model - so `acevars = c("extraversion", "education")` - and education is a ordinal variable, you need to write `acevars = "education"`. By default, the function assumes that all variables are continuous.
- `optimizer`: Choose your preferred estimator. There are three options: `"SLSQP"`, `"NPSOL"` and `"CSOLNP"`. You can check the OpenMx documentation or the OpenMx forum to figure out the differences. "SLSQP" is the default
- `tryHard`: If `TRUE` the function uses `mxTryHard()` to estimate the model, which means that it makes multiple attempts to fit the model with different starting values. Sometimes bad starting values can ruin your model (although I tried to choose them wisely). The default is `FALSE`. So, if you encounter some problems you may switch to `tryHard = TRUE`
- `type`: Here you can choose the default model type for the multivariate case: `type = "aceb"` refers to the ACE beta model (it's the default) and `type = "chol"` refers to the Cholesky model. Soon. If implemented, you can choose between `type = "CF"` for the correlated factor model and `type = "VC"` for the variance component model, as well. 
