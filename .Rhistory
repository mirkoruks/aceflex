# Trivariate Cholesky Model
rm(list = ls())
library(dplyr)
#library(OpenMx)
library(xtable)
data_orig <- read.csv(file = "C:/Users/Besitzer/Documents/Arbeit/Twinlife/Artikel/Netzwerke/Git/netzwerke/Update/data_wide.csv",
header = TRUE)
summary(data_orig)
acevars <- c("posbez", "schoolhigh", "iseiempmean")
acevars1 <-    paste0(acevars,"_1") # ACE vars twin 1
vars1 <- c(acevars1) # All variables for twin 1
acevars2 <-    paste0(acevars,"_2") # ACE vars twin 2
vars2 <- c(acevars2) # All variables for twin 2
acevarswide <- c(acevars1, acevars2) # ACE vars variable vector (input for SEM)
varswide <- c(vars1,vars2)
## NEED TO SCALE BEFORE!
## NEED TO CHECK MISSING DATA STRUCTURE BEFORE!
#data <- data[rowSums(is.na(data)) != ncol(data),]
#####################################################################################################
#####################################################################################################
#####################################################################################################
#####################################################################################################
# aceflex function
aceflex <- function(acevars, data, zyg, covvars=NULL) {
if ("OpenMx" %in% (.packages()) == FALSE) {
stop("You need to load the OpenMx library: \nuse library(OpenMx)\n...Science is standing on the shoulders of giants and so does this function... :-)")
}
if (is.null(acevars)) {
stop("You need to specify a string vector with variables for the ACE decomposition")
}
if (is.null(data)) {
stop("You need to specify a data set")
}
if (is.null(zyg)) {
stop("You need to specify a zygosity variable")
}
if (!is.null(covvars) & class(covvars)!= "character") {
stop("Please, use a string vector to specify the covariates")
}
# Output-List -> Print results
output <- list()
## check here if covariates are constants or not!
# Transform vars from long to wide
acevars1 <-    paste0(acevars,"_1") # ACE vars twin 1
acevars2 <-    paste0(acevars,"_2") # ACE vars twin 2
if (is.null(covvars)) {
covvars1 <- covvars
covvars2 <- covvars
}
# here comes the else if option for constant covariates!
else {
covvars1 <-    paste0(covvars,"_1") # Covariates twin 1
covvars2 <-    paste0(covvars,"_2") # Covariates twin 2
}
vars1 <- c(acevars1,covvars1) # All variables for twin 1
vars2 <- c(acevars2,covvars2) # All variables for twin 2
variables <- c(acevars1, acevars2, covvars1, covvars2) # ACE vars variable vector (input for SEM)
# Check if acevars have within-twin-pair-variance -> give warning if correlation > .9
#####################################################################################################
#### When function allows for covariates in the covariance matrix we can add them here as well ! ####
#####################################################################################################
acevarscor <- mapply(cor,data[,acevars1],data[,acevars2], use = "pairwise.complete.obs")
#acevarscor[3] <- .98
s = attr(acevarscor, "names")
s1 = unlist(sapply(strsplit(s, split='_', fixed=TRUE), function(x) (x[1])))
attr(acevarscor, "names") <- s1
lowcorrelation <- acevarscor < 0.9
alllowcorrelation <- all(lowcorrelation)
if (alllowcorrelation == FALSE) {
highcorrelation <- acevarscor[acevarscor >=.9]
highcorrelationnames <- attributes(highcorrelation)
print("Oups! For the following variables the within-pair correlation is >= 0.9 and < 1. There might be estimation problems due to (multi-)collinearity")
print(highcorrelation)
proceedcollinearity <- readline("Do you want to proceed? You still want to proceed? Then type 'yes' You want to stop? Then type 'no' (Without quotes)")
if (proceedcollinearity == "no") {
stop("User did not want to proceed due to (multi-)collinearity in one of the variables. Function aceflex has stopped! See you soon!")
}
}
# Check if covariates are constants or have within-pair-variance
#
#
#
#
#
usevariables <- c(variables,"zyg")
usedata <- subset(data, select = c(usevariables)) # Data set with only variables used for the model
cat("\n\n\nSummary total Data\n\n")
print(summary(usedata))
# Check if zygosity variable is coded correctly
if (min(data$zyg) != 1 & max(data$zyg) != 2) {
stop("Zygosity variable must be coded as follows: 1 = MZ, 2 = DZ. Please, recode the zygosity variable.")
}
# Starting Values
# Means Vector
svmean1 <- colMeans(usedata[,vars1], na.rm=TRUE)
svmean2 <- colMeans(usedata[,vars2], na.rm=TRUE)
svmean <- rowMeans(cbind(svmean1,svmean2), na.rm=TRUE)
cat("\n\n\nStarting Values for the mean vector\n\n")
print(svmean)
# Covariance Matrix of the covariates (at the moment the function uses default values)
if (!is.null(covvars)) {
# here comes the code ! :-)
# here something to begin with
# unname(as.matrix(cor(data[,covariates], use = "na.or.complete"))) # S matrix starting values for non-decomposed covariates
# svS <- round(unname(as.matrix(cov(data[,covariates], use = "na.or.complete"))),3) # S matrix starting values for non-decomposed covariates
# svS
}
# define the MZ and DZ data sets
mzData    <- subset(usedata, zyg==1, variables)
dzData    <- subset(usedata, zyg==2, variables)
cat("\n\n\nSummary MZ Data\n\n")
print(summary(mzData))
cat("\n\n\nSummary DZ Data\n\n")
print(summary(dzData))
# Shortcuts for the matrix dimensions
# No. of Variables
nv <- length(acevars) # Vars per twin
ntv <- nv*2 # Vars per twin pair
m <- (nv*2) # Decomposed manifest variables
c <- length(acevars) # Control variables
l <- 3*nv*2
t <- m+l+c
# Build elements to construct expected covariance matrix (RAM Notation)
# Matrix A
# Helper objects for object of manifest paths between acevars
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathB <- lower.tri(mat)
freepathB
mat[upper.tri(mat, diag = TRUE)] <- 0
valuespathB <- mat
valuespathB
nvstring <- as.character(1:nv)
pathBlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathBlabel[upper.tri(pathBlabel, diag = TRUE)] <- NA
pathBlabel
pathB <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathB,
values = valuespathB,
labels = pathBlabel,
name = "b")
print(pathB)
cat("\n\n\n... Bis hierhin läuft alles durch! Weiter geht's! :-)")
}
aceflex(acevars = acevars, data = data_orig,zyg = "zyg")
library(OpenMx)
# aceflex function
aceflex <- function(acevars, data, zyg, covvars=NULL) {
if ("OpenMx" %in% (.packages()) == FALSE) {
stop("You need to load the OpenMx library: \nuse library(OpenMx)\n...Science is standing on the shoulders of giants and so does this function... :-)")
}
if (is.null(acevars)) {
stop("You need to specify a string vector with variables for the ACE decomposition")
}
if (is.null(data)) {
stop("You need to specify a data set")
}
if (is.null(zyg)) {
stop("You need to specify a zygosity variable")
}
if (!is.null(covvars) & class(covvars)!= "character") {
stop("Please, use a string vector to specify the covariates")
}
# Output-List -> Print results
output <- list()
## check here if covariates are constants or not!
# Transform vars from long to wide
acevars1 <-    paste0(acevars,"_1") # ACE vars twin 1
acevars2 <-    paste0(acevars,"_2") # ACE vars twin 2
if (is.null(covvars)) {
covvars1 <- covvars
covvars2 <- covvars
}
# here comes the else if option for constant covariates!
else {
covvars1 <-    paste0(covvars,"_1") # Covariates twin 1
covvars2 <-    paste0(covvars,"_2") # Covariates twin 2
}
vars1 <- c(acevars1,covvars1) # All variables for twin 1
vars2 <- c(acevars2,covvars2) # All variables for twin 2
variables <- c(acevars1, acevars2, covvars1, covvars2) # ACE vars variable vector (input for SEM)
# Check if acevars have within-twin-pair-variance -> give warning if correlation > .9
#####################################################################################################
#### When function allows for covariates in the covariance matrix we can add them here as well ! ####
#####################################################################################################
acevarscor <- mapply(cor,data[,acevars1],data[,acevars2], use = "pairwise.complete.obs")
#acevarscor[3] <- .98
s = attr(acevarscor, "names")
s1 = unlist(sapply(strsplit(s, split='_', fixed=TRUE), function(x) (x[1])))
attr(acevarscor, "names") <- s1
lowcorrelation <- acevarscor < 0.9
alllowcorrelation <- all(lowcorrelation)
if (alllowcorrelation == FALSE) {
highcorrelation <- acevarscor[acevarscor >=.9]
highcorrelationnames <- attributes(highcorrelation)
print("Oups! For the following variables the within-pair correlation is >= 0.9 and < 1. There might be estimation problems due to (multi-)collinearity")
print(highcorrelation)
proceedcollinearity <- readline("Do you want to proceed? You still want to proceed? Then type 'yes' You want to stop? Then type 'no' (Without quotes)")
if (proceedcollinearity == "no") {
stop("User did not want to proceed due to (multi-)collinearity in one of the variables. Function aceflex has stopped! See you soon!")
}
}
# Check if covariates are constants or have within-pair-variance
#
#
#
#
#
usevariables <- c(variables,"zyg")
usedata <- subset(data, select = c(usevariables)) # Data set with only variables used for the model
cat("\n\n\nSummary total Data\n\n")
print(summary(usedata))
# Check if zygosity variable is coded correctly
if (min(data$zyg) != 1 & max(data$zyg) != 2) {
stop("Zygosity variable must be coded as follows: 1 = MZ, 2 = DZ. Please, recode the zygosity variable.")
}
# Starting Values
# Means Vector
svmean1 <- colMeans(usedata[,vars1], na.rm=TRUE)
svmean2 <- colMeans(usedata[,vars2], na.rm=TRUE)
svmean <- rowMeans(cbind(svmean1,svmean2), na.rm=TRUE)
cat("\n\n\nStarting Values for the mean vector\n\n")
print(svmean)
# Covariance Matrix of the covariates (at the moment the function uses default values)
if (!is.null(covvars)) {
# here comes the code ! :-)
# here something to begin with
# unname(as.matrix(cor(data[,covariates], use = "na.or.complete"))) # S matrix starting values for non-decomposed covariates
# svS <- round(unname(as.matrix(cov(data[,covariates], use = "na.or.complete"))),3) # S matrix starting values for non-decomposed covariates
# svS
}
# define the MZ and DZ data sets
mzData    <- subset(usedata, zyg==1, variables)
dzData    <- subset(usedata, zyg==2, variables)
cat("\n\n\nSummary MZ Data\n\n")
print(summary(mzData))
cat("\n\n\nSummary DZ Data\n\n")
print(summary(dzData))
# Shortcuts for the matrix dimensions
# No. of Variables
nv <- length(acevars) # Vars per twin
ntv <- nv*2 # Vars per twin pair
m <- (nv*2) # Decomposed manifest variables
c <- length(acevars) # Control variables
l <- 3*nv*2
t <- m+l+c
# Build elements to construct expected covariance matrix (RAM Notation)
# Matrix A
# Helper objects for object of manifest paths between acevars
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathB <- lower.tri(mat)
freepathB
mat[upper.tri(mat, diag = TRUE)] <- 0
valuespathB <- mat
valuespathB
nvstring <- as.character(1:nv)
pathBlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathBlabel[upper.tri(pathBlabel, diag = TRUE)] <- NA
pathBlabel
pathB <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathB,
values = valuespathB,
labels = pathBlabel,
name = "b")
print(pathB)
cat("\n\n\n... Bis hierhin läuft alles durch! Weiter geht's! :-)")
}
aceflex(acevars = acevars, data = data_orig,zyg = "zyg")
