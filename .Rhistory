}
modACEbivvars
modBetavars
modmat <- matrix(0,nrow = 3,ncol = 3, dimnames = list(acevars,acevars))
modpathACEfree <- modmat!=0
for (i in modACEbivvars) {
modpathACEfree[as.vector(i)[2],as.vector(i)[1]] <- TRUE
modpathACEfree
}
modpathACEfree
labelList <- list()
for (i in c("a","c","e")) {
pathModlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",i,x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathModlabel[upper.tri(pathAModlabel, diag = FALSE)] <- NA
labelList[[i]] <-pathModlabel
}
labelList
# Implement moderation
library(OpenMx)
# moderation only of paths from ACE components on decomposed variables and from decomposed variables on decomposed variables
# new arguments:
# moderation = NULL ## TRUE if moderation needed
# modACEuniv = NULL ## if moderation = TRUE -> specify here if you want to moderate univariate ACE paths, and if yes, of which variables
# input element = character vector of variables: The univariate ACE paths of each variable specified in the vector will be moderated
# modACEbiv = NULL ## if moderation = TRUE -> specify here if you want to moderate bivariate ACE paths, and if yes, of which variable pairs
# input element = character vector of variable relationships
# e.g.: Both, X and Y are ACE decomposed variables and the user wants to moderate the effect of the ACE components of X on Y ->
# the user needs to write: modACEbiv = "X -> Y"
# modBeta = NULL ## if moderation = TRUE -> specify here if you want to moderate a phenotypic paths between acevars, and if yes, of which variables
# necessary stuff to keep it running
acevars <- c("X","Z","Y") # three variables to be decomposed into ACE components
nv <- length(acevars) # Vars per twin
modACEbiv <- c("X   -> Y","Z -> Y")
modBeta <- c("X->Y")
modACEbiv2 <- c("X   -> Y BY Mod1","Z -> Y BY Mod1 + Mod2")
modACEbiv2
#grepl("+",modACEbiv2)
#strsplit(modACEbiv2, split = "\\->|BY|\\+")
splitit <- function(input) {
if (grepl("+",input) == TRUE) {
result <- unlist(strsplit(input, split = "\\->|BY|\\+"))
} else {
result <- unlist(strsplit(input, split = "\\->|BY"))
}
}
test <- lapply(modACEbiv2,splitit)
moderatedbivACE <- vector(mode = "list", length = length(modACEbiv2))
moderatorbivACE <- vector(mode = "list", length = length(modACEbiv2))
for (i in 1:length(modACEbiv2)) {
test[[i]] <- trimws(test[[i]])
moderatedbivACE[[i]] <- test[[i]][1:2] # save moderated vars
moderatorbivACE[[i]] <- test[[i]][3:length(test[[i]])] # save moderators
}
test
moderatedbivACE
moderatorbivACE
modvarsACEbiv <- unique(unlist(moderatorbivACE))
modvarsACEbiv
# create matrix of interaction effects
modmat <- matrix(0,nrow = 3,ncol = 3, dimnames = list(acevars,acevars))
modpathACEfree <- modmat!=0
modpathACEfree
freeList <- list()
for (j in modvarsACEbiv) {
freevector <- modpathACEfree
for (i in test) {
if (j %in% i) {
freevector[as.vector(i)[2],as.vector(i)[1]] <- TRUE
freeList[[j]] <-  freevector
}
}
}
freeList
freemat <- NULL
for (name in names(freeList)) {
print(name)
print(freeList[[name]])
assign(paste0("freemat", name), freeList[[name]])
}
labelList <- list()
nvstring <- as.character(1:nv)
for (i in c("a","c","e")) {
pathModlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",i,x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathModlabel[upper.tri(pathAModlabel, diag = FALSE)] <- NA
labelList[[i]] <-pathModlabel
}
labelList
freeList["Mod1"]
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0(i,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = index)
pathModStore[[index]] <- matrixstore
}
}
pathModStore
#assign(paste0("path", i,j), pathModStore)
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
for (i in names(freeList)) {
name <- paste0("def",i)
labeldefmod <- paste0("data.",i)
defMod[[i]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=labeldefmod, name=name )
}
View(defMod)
moderatedACE <- list()
for (i in names(defMod)) {
for (j in names(pathModStore)) {
if (grepl(i,j)) {
namevec <- paste0("M",j)
path <- pathModStore[[j]]@name
def <- defMod[[i]]@name
moderatedACE[[namevec]] <- mxAlgebra(expression = path * def, name = namevec)
}
}
}
View(moderatedACE)
moderatedACE <- list()
for (i in names(defMod)) {
for (j in names(pathModStore)) {
if (grepl(i,j)) {
namevec <- paste0("M",j)
path <- pathModStore[[j]]@name
def <- defMod[[i]]@name
moderatedACE[[namevec]] <- mxAlgebra(expression = !!as.symbol(path) * !!as.symbol(def), name = namevec)
}
}
}
View(moderatedACE)
?mxAlgebra
for (i in names(defMod)) {
for (j in names(pathModStore)) {
if (grepl(i,j)) {
namevec <- paste0("M",j)
moderatedACE[[namevec]] <- mxAlgebra(expression = pathModStore[[j]]@name * defMod[[i]]@name, name = namevec)
}
}
}
View(defMod)
View(pathModStore)
View(defMod)
View(pathModStore)
names(defMod)
def <- NULL
for (i in names(defMod)) {
assign(paste0("def", i), defMod[[i]])
}
path <- NULL
for (i in names(pathModStore)) {
assign(paste0("path", i), pathModStore[[i]])
}
moderator
modvarsACEbiv
defMod1
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
count = 1
for (i in names(freeList)) {
index <- paste0("defMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=labeldefmod, name= index)
count <- count +1
}
View(defMod)
View(pathModStore)
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0("path",i,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = index)
pathModStore[[index]] <- matrixstore
}
}
pathModStore
View(pathModStore)
count <- 1
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0("pathMod",count,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = index)
pathModStore[[index]] <- matrixstore
}
count <- count+1
}
View(pathModStore)
freeList
test
modvarsACEbiv
freeList <- list()
count <- 1
for (j in modvarsACEbiv) {
freevector <- modpathACEfree
for (i in test) {
if (j %in% i) {
index <- paste0("Mod",count)
freevector[as.vector(i)[2],as.vector(i)[1]] <- TRUE
freeList[[index]] <-  freevector
}
}
count <- count+1
}
View(freeList)
for (name in names(freeList)) {
print(name)
print(freeList[[name]])
assign(paste0("freemat", name), freeList[[name]])
}
freemat
labelList <- list()
nvstring <- as.character(1:nv)
for (i in c("a","c","e")) {
pathModlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",i,x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathModlabel[upper.tri(pathAModlabel, diag = FALSE)] <- NA
labelList[[i]] <-pathModlabel
}
View(labelList)
# Implement moderation
library(OpenMx)
# moderation only of paths from ACE components on decomposed variables and from decomposed variables on decomposed variables
# new arguments:
# moderation = NULL ## TRUE if moderation needed
# modACEuniv = NULL ## if moderation = TRUE -> specify here if you want to moderate univariate ACE paths, and if yes, of which variables
# input element = character vector of variables: The univariate ACE paths of each variable specified in the vector will be moderated
# modACEbiv = NULL ## if moderation = TRUE -> specify here if you want to moderate bivariate ACE paths, and if yes, of which variable pairs
# input element = character vector of variable relationships
# e.g.: Both, X and Y are ACE decomposed variables and the user wants to moderate the effect of the ACE components of X on Y ->
# the user needs to write: modACEbiv = "X -> Y"
# modBeta = NULL ## if moderation = TRUE -> specify here if you want to moderate a phenotypic paths between acevars, and if yes, of which variables
# necessary stuff to keep it running
acevars <- c("X","Z","Y") # three variables to be decomposed into ACE components
nv <- length(acevars) # Vars per twin
modACEbiv <- c("X   -> Y","Z -> Y")
modBeta <- c("X->Y")
modACEbiv2 <- c("X   -> Y BY K","Z -> Y BY K + Mod2")
modACEbiv2
#grepl("+",modACEbiv2)
splitit <- function(input) {
if (grepl("+",input) == TRUE) {
result <- unlist(strsplit(input, split = "\\->|BY|\\+"))
} else {
result <- unlist(strsplit(input, split = "\\->|BY"))
}
}
test <- lapply(modACEbiv2,splitit)
test
moderatedbivACE <- vector(mode = "list", length = length(modACEbiv2))
moderatorbivACE <- vector(mode = "list", length = length(modACEbiv2))
for (i in 1:length(modACEbiv2)) {
test[[i]] <- trimws(test[[i]])
moderatedbivACE[[i]] <- test[[i]][1:2] # save moderated vars
moderatorbivACE[[i]] <- test[[i]][3:length(test[[i]])] # save moderators
}
test
moderatedbivACE
moderatorbivACE
modvarsACEbiv <- unique(unlist(moderatorbivACE))
modvarsACEbiv
# create matrix of interaction effects
modmat <- matrix(0,nrow = 3,ncol = 3, dimnames = list(acevars,acevars))
modpathACEfree <- modmat!=0
modpathACEfree
# create matrix of interaction effects
modmat <- matrix(0,nrow = 3,ncol = 3, dimnames = list(acevars,acevars))
modpathACEfree <- modmat!=0
freeList <- list()
count <- 1
for (j in modvarsACEbiv) {
freevector <- modpathACEfree
for (i in test) {
if (j %in% i) {
index <- paste0("Mod",count)
freevector[as.vector(i)[2],as.vector(i)[1]] <- TRUE
freeList[[index]] <-  freevector
}
}
count <- count+1
}
View(freeList)
labelList <- list()
nvstring <- as.character(1:nv)
for (i in c("a","c","e")) {
pathModlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",i,x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathModlabel[upper.tri(pathAModlabel, diag = FALSE)] <- NA
labelList[[i]] <-pathModlabel
}
View(labelList)
# Implement moderation
library(OpenMx)
# moderation only of paths from ACE components on decomposed variables and from decomposed variables on decomposed variables
# new arguments:
# moderation = NULL ## TRUE if moderation needed
# modACEuniv = NULL ## if moderation = TRUE -> specify here if you want to moderate univariate ACE paths, and if yes, of which variables
# input element = character vector of variables: The univariate ACE paths of each variable specified in the vector will be moderated
# modACEbiv = NULL ## if moderation = TRUE -> specify here if you want to moderate bivariate ACE paths, and if yes, of which variable pairs
# input element = character vector of variable relationships
# e.g.: Both, X and Y are ACE decomposed variables and the user wants to moderate the effect of the ACE components of X on Y ->
# the user needs to write: modACEbiv = "X -> Y"
# modBeta = NULL ## if moderation = TRUE -> specify here if you want to moderate a phenotypic paths between acevars, and if yes, of which variables
# necessary stuff to keep it running
acevars <- c("X","Z","Y") # three variables to be decomposed into ACE components
nv <- length(acevars) # Vars per twin
modACEbiv <- c("X   -> Y","Z -> Y")
modBeta <- c("X->Y")
modACEbiv2 <- c("X   -> Y BY K","Z -> Y BY K + Mod2")
modACEbiv2
#grepl("+",modACEbiv2)
#strsplit(modACEbiv2, split = "\\->|BY|\\+")
splitit <- function(input) {
if (grepl("+",input) == TRUE) {
result <- unlist(strsplit(input, split = "\\->|BY|\\+"))
} else {
result <- unlist(strsplit(input, split = "\\->|BY"))
}
}
test <- lapply(modACEbiv2,splitit)
moderatedbivACE <- vector(mode = "list", length = length(modACEbiv2))
moderatorbivACE <- vector(mode = "list", length = length(modACEbiv2))
for (i in 1:length(modACEbiv2)) {
test[[i]] <- trimws(test[[i]])
moderatedbivACE[[i]] <- test[[i]][1:2] # save moderated vars
moderatorbivACE[[i]] <- test[[i]][3:length(test[[i]])] # save moderators
}
test
moderatedbivACE
moderatorbivACE
modvarsACEbiv <- unique(unlist(moderatorbivACE))
modvarsACEbiv
# create matrix of interaction effects
modmat <- matrix(0,nrow = 3,ncol = 3, dimnames = list(acevars,acevars))
modpathACEfree <- modmat!=0
freeList <- list()
count <- 1
for (j in modvarsACEbiv) {
freevector <- modpathACEfree
for (i in test) {
if (j %in% i) {
index <- paste0("Mod",count)
freevector[as.vector(i)[2],as.vector(i)[1]] <- TRUE
freeList[[index]] <-  freevector
}
}
count <- count+1
}
View(freeList)
labelList <- list()
nvstring <- as.character(1:nv)
for (i in c("a","c","e")) {
pathModlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",i,x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathModlabel[upper.tri(pathAModlabel, diag = FALSE)] <- NA
labelList[[i]] <-pathModlabel
}
View(labelList)
count <- 1
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0("pathMod",count,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = index)
pathModStore[[index]] <- matrixstore
}
count <- count+1
}
View(pathModStore)
#assign(paste0("path", i,j), pathModStore)
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
count = 1
for (i in names(freeList)) {
index <- paste0("defMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=labeldefmod, name= index)
count <- count +1
}
View(defMod)
View(pathModStore)
def <- NULL
for (i in names(defMod)) {
assign(paste0("def", i), defMod[[i]])
}
path <- NULL
for (i in names(pathModStore)) {
assign(paste0("path", i), pathModStore[[i]])
}
View(defMod)
defMod1
View(pathModStore)
pathModStore[["pathMod1a"]]@name
View(pathModStore)
moderatorbivACE
View(defMod)
View(freeList)
moderatorbivACE
modvarsACEbiv
for (i in modvarsACEbiv) {
index <- paste0("defMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=labeldefmod, name= index)
count <- count +1
}
View(defMod)
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
count = 1
for (i in modvarsACEbiv) {
index <- paste0("defMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=labeldefmod, name= index)
count <- count +1
}
View(defMod)
modvarsACEbiv
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
count = 1
for (i in modvarsACEbiv) {
index <- paste0("defMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=label, name= index)
count <- count +1
}
View(defMod)
test <- c(T,T,T,F,F)
test
test[1:2] == T
modvars <- modvarsACEbiv
modvarswide <- c(F,F)
modvars
modvarswide
modvarswide <- c(F,T)
modvarswide
modvarswide==F
modvarswide <- c(F,F)
modvarswide==F
modvarswide==F==F
F %in% modvarswide
T %in% modvarswide
View(pathModStore)
modvars
modvars[3]
View(defMod)
defMod[["defMod1"]]@name
count <- 1
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0("pathMod",count,j)
name <- paste0("pM",count,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = name)
pathModStore[[index]] <- matrixstore
}
count <- count+1
}
View(pathModStore)
count <- 1
pathModStore <- list()
for (i in names(freeList)) {
for (j in names(labelList)) {
index <- paste0("pathMod",count,j)
name <- paste0("pMod",count,j)
matrixstore <- mxMatrix(type = "Full", nrow = nv, ncol = nv, byrow = TRUE,
labels = labelList[[j]],
free = freeList[[i]],
values = 0,
name = name)
pathModStore[[index]] <- matrixstore
}
count <- count+1
}
View(pathModStore)
# create list with matrices of moderators of bivariate ACE paths
defMod <- list()
count = 1
for (i in modvarsACEbiv) {
index <- paste0("dMod",count)
label <- paste0("data.",i)
defMod[[index]]      <- mxMatrix( type="Full", nrow=1, ncol=1, free=FALSE, labels=label, name= index)
count <- count +1
}
View(defMod)
View(defMod)
defMod[["dMod1"]]@name
for (i in names(defMod)) {
for (j in names(pathModStore)) {
if (grepl(i,j)) {
namevec <- paste0("M",j)
moderatedACE[[namevec]] <- mxAlgebra(expression = pathModStore[[j]]@name * defMod[[i]]@name, name = namevec)
}
}
}
View(moderatedACE)
