variables <- c(acevarswide,covvarsall)
cat(paste0("\n\n\nAll in all, there are ",length(variables)," variables: \n\n"))
print(variables)
rna <- function(x) replace(x, is.na(x), "")
checkvariance <- function(v1,v2) {
identicalcheck <- as.vector(colSums(ifelse(rna(data_orig[,v1, drop = FALSE])==rna(data_orig[,v2, drop = FALSE]), 0, 1)))
if (0 %in% identicalcheck == TRUE) {
ind <- identicalcheck==0
result1 <- v1[ind]
result2 <- v2[ind]
result <- c(result1,result2)
if (!is.null(result)) {
stop(c("The following acevars are identical and have no within-variance: ",paste(result, sep = " ", collapse = ", ")))
}
}
else {
cat("\n\n\nAll the wide-formatted variables have within-pair variance")
}
}
checkvariance(varswide1,varswide2)
usevariables <- c(variables,"zyg")
usedata <- subset(data, select = c(usevariables)) # Data set with only variables used for the model
cat("\n\n\nSummary total Data\n\n")
print(summary(usedata))
# Check if zygosity variable is coded correctly
if (min(data$zyg) != 1 & max(data$zyg) != 2) {
stop("Zygosity variable must be coded as follows: 1 = MZ, 2 = DZ. Please, recode the zygosity variable.")
}
# Starting Values
# Means Vector
# acevars
svmeanacevarswide1 <- colMeans(usedata[,acevars1, drop = FALSE], na.rm=TRUE)
svmeanacevarswide2 <- colMeans(usedata[,acevars2, drop = FALSE], na.rm=TRUE)
svmeanacevars <- rowMeans(cbind(svmeanacevarswide1, svmeanacevarswide2), na.rm=TRUE)
cat("\n\n\nStarting Values of the acevars for the mean vector\n\n")
print(svmeanacevars)
# covvars
# wide
if (!is.null(covvarswide)) {
svmeancovvarswide1 <- colMeans(usedata[,covvars1, drop = FALSE], na.rm=TRUE)
svmeancovvarswide2 <- colMeans(usedata[,covvars2, drop = FALSE], na.rm=TRUE)
svmeancovvarswide <- rowMeans(cbind(svmeancovvarswide1, svmeancovvarswide2), na.rm=TRUE)
} else {
svmeancovvarswide <- NULL
}
# long
if (!is.null(covvarslong_checked)) {
svmeancovvarslong <-  colMeans(usedata[,covvarslong_checked, drop = FALSE], na.rm=TRUE)
} else {
svmeancovvarslong <- NULL
}
# all
svmeancovvars <- c(svmeancovvarslong,svmeancovvarswide)
svmean <- c(svmeanacevars,svmeancovvars)
cat("\n\n\nStarting Values of the covvars for the mean vector\n\n")
if (!is.null(svmeancovvars)) {
print(svmeancovvars)
} else {
cat("There are no covariates")
}
cat("\n\n\nStarting Values for the mean vector\n\n")
print(svmean)
# Covariance Matrix of the covariates (at the moment the function uses default values)
if (!is.null(covvars)) {
# here comes the code ! :-)
# here something to begin with
# unname(as.matrix(cor(data[,covariates], use = "na.or.complete"))) # S matrix starting values for non-decomposed covariates
# svS <- round(unname(as.matrix(cov(data[,covariates], use = "na.or.complete"))),3) # S matrix starting values for non-decomposed covariates
# svS
}
# define the MZ and DZ data sets
mzData    <- subset(usedata, zyg==1, variables)
dzData    <- subset(usedata, zyg==2, variables)
cat("\n\n\nSummary MZ Data\n\n")
print(summary(mzData))
cat("\n\n\nSummary DZ Data\n\n")
print(summary(dzData))
# Shortcuts for the matrix dimensions
# No. of Variables
nv <- length(acevars) # Vars per twin
ntv <- nv*2 # Vars per twin pair
m <- (nv*2) # Decomposed manifest variables
c <- length(covvarsall) # Control variables
l <- 3*nv*2
t <- m+l+c
# Build elements to construct expected covariance matrix (RAM Notation)
# Matrix A
# Helper objects for object of manifest paths between acevars f
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathB <- lower.tri(mat)
freepathB
mat[upper.tri(mat, diag = TRUE)] <- 0
valuespathB <- mat
valuespathB
nvstring <- as.character(1:nv)
pathBlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathBlabel[upper.tri(pathBlabel, diag = TRUE)] <- NA
pathBlabel
pathB <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathB,
values = valuespathB,
labels = pathBlabel,
name = "b")
pathZ <- mxMatrix(type = "Zero", nrow = nv, ncol = nv, name = "pZ")
pathCov_label_variance <- function(string) {
stringend <- substring(string, nchar(string)) == "1"
if  (stringend == TRUE) {
c(paste0("b",string,1:nv),rep(NA,nv))
}
else {
c(rep(NA,nv),paste0("b",string,1:nv))
}
}
pathCovlabelvariance <- as.matrix(sapply(covvarswide,pathCov_label_variance))
if (length(pathCovlabelvariance)==0) {
pathCovlabelvariance <- NULL
}
pathCovvaluevariance <- pathCovlabelvariance
pathCovvaluevariance[!is.na(pathCovvaluevariance)] <- .3
pathCovvaluevariance[is.na(pathCovvaluevariance)] <- 0
mode(pathCovvaluevariance) <- "numeric"
pathCovfreevariance <- pathCovvaluevariance==.3
## Cov Vars without variances
pathCov_label_constant <- function(string) {
paste0("b",rep(paste0(string,1:nv),2),rep(c(1,2),each=nv))
}
pathCovlabelconstant <- as.matrix(sapply(covvarslong_checked,pathCov_label_constant))
if (length(pathCovlabelconstant)==0) {
pathCovlabelconstant <- NULL
}
pathCovvalueconstant <- pathCovlabelconstant
pathCovvalueconstant[!is.na(pathCovvalueconstant)] <- .3
pathCovvalueconstant[is.na(pathCovvalueconstant)] <- 0
mode(pathCovvalueconstant) <- "numeric"
pathCovfreeconstant <- pathCovvalueconstant==.3
pathCovlabel <- cbind(pathCovlabelconstant,pathCovlabelvariance)
pathCovvalue <- cbind(pathCovvalueconstant,pathCovvaluevariance)
pathCovfree <- cbind(pathCovfreeconstant,pathCovfreevariance)
pathCov <- mxMatrix(type = "Full", nrow = ntv, ncol = c, byrow = FALSE,
free = pathCovfree,
values = pathCovvalue,
labels = pathCovlabel,
name = "pCov")
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathAC <- lower.tri(mat, diag = TRUE)
freepathAC
mat[upper.tri(mat, diag = FALSE)] <- 0
valuespathAC <- mat
valuespathAC
mat[lower.tri(mat, diag = FALSE)] <- 0
valuespathE <- mat
valuespathE
freepathE <- valuespathE == .3
freepathE
nvstring <- as.character(1:nv)
pathAlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("a",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathAlabel[upper.tri(pathAlabel, diag = FALSE)] <- NA
pathAlabel
pathClabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("c",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathClabel[upper.tri(pathClabel, diag = FALSE)] <- NA
pathClabel
pathElabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("e",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathElabel[upper.tri(pathClabel, diag = FALSE)] <- NA
pathElabel
pathA <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathAC,
values = valuespathAC,
labels = pathAlabel,
name = "a")
pathC <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathAC,
values = valuespathAC,
labels = pathClabel,
name = "c")
pathE <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathE,
values = valuespathE,
labels = pathElabel,
name = "e")
print(pathB)
print(pathCov)
print(pathA)
print(pathC)
print(pathE)
cat("\n\n\n... Bis hierhin läuft alles durch! Weiter geht's! :-)")
}
twinflex(acevars = c("kultkapjahre"), covvars = c("age"),data = data_orig,sep = "_",zyg = "zyg")
rm(list = ls())
library(dplyr)
library(OpenMx)
library(xtable)
data_orig <- read.csv(file = "C:/Users/Besitzer/Documents/Arbeit/Twinlife/Artikel/Netzwerke/Git/netzwerke/Update/data_wide.csv",
header = TRUE)
summary(data_orig)
# twinflex function
twinflex <- function(acevars, data, zyg, sep, covvars=NULL) {
if ("OpenMx" %in% (.packages()) == FALSE) {
stop("You need to load the OpenMx library")
}
if (is.null(acevars)) {
stop("You need to specify a string vector with variables for the ACE decomposition")
}
if (is.null(data)) {
stop("You need to specify a data set")
}
if (is.null(zyg)) {
stop("You need to specify a zygosity variable")
}
if (is.null(sep)) {
stop("You need to specify a separator. Example: The variable names are 'iq_t1' and 'iq_t2', then your seperator is '_t'")
}
if (length(sep) > 1) {
stop("Please specify the separator with a string vector with one element only.")
}
if (!is.null(covvars) & class(covvars)!= "character") {
stop("Please, use a string vector to specify the covariates")
}
# Output-List -> Print results
output <- list()
# Create acevars in wide format using sep
acevars1 <-    paste0(acevars,sep,"1") # ACE vars twin 1
acevars2 <-    paste0(acevars,sep,"2") # ACE vars twin 2
############ CHECK IF ACEVARS AND/OR COVVARS 1) EXIST AND 2) FOR THE WIDE FORMATTED ONES: IF THEY HAVE WITHIN-VARIANCE
#######
# 1. check if variables exist --> for acevars in wide format and for covvars in both long (without within-pair variance) and wide (with within-pair variance)
#######
existence <- function(variable) {
result <- NULL
if(variable %in% colnames(data))
{
result <- NULL
}
else if (!(variable %in% colnames(data))) {
result <- variable
}
}
existenceerror <- function(result) {
if (!is.null(result)) {
stop(c("I could not find a variable(s) in the data frame corresponding to the following variable strings you gave me: ",paste(result, sep = " ", collapse = ", ")))
}
else {
print("alles gut")
}
}
# 1a: Check for acevars (only in wide since they have to have within-pair-variance)
acevars1 <-    paste0(acevars,sep,"1") # Covariates twin 1
acevars2 <-    paste0(acevars,sep,"2") # Covariates twin 2
acevarswide <- c(acevars1, acevars2)
existence_check_acevars <- unlist(lapply(acevarswide, existence))
if (!is.null(existence_check_acevars)) {
acevars_not_found <- unlist(sapply(strsplit(existence_check_acevars, split=sep, fixed=TRUE), function(x) (x[1])))
acevars_not_found <- unique(acevars_not_found)
#existenceerror(existence_check_acevars)
} else {
acevars_not_found <- NULL
}
# 1b: Check for covvars (can be in wide and long) -> 1. Check for wide -> 2. Check for Long if something does not appear as wide
if (!is.null(covvars) & class(covvars)== "character") {
covvars1 <-    paste0(covvars,sep,"1") # Covariates twin 1
covvars2 <-    paste0(covvars,sep,"2") # Covariates twin 2
covvarswide <- c(covvars1, covvars2)
existence_check_covvars <- unlist(lapply(covvarswide, existence))
covvarswide_checked <- covvarswide[!covvarswide %in% existence_check_covvars] # object with wide-formatted covariates
existence_check_covvars # object with possibly long-formatted covariates -> check if really long or if typo
if (!is.null(existence_check_covvars)) { # if the object with possibly long-formatted covariates is not empty -> check if there are long-formatted covariates
covvars_possibly_long_format <- covvarswide[covvarswide %in% existence_check_covvars]
covvars_possibly_long_format <- unlist(sapply(strsplit(covvars_possibly_long_format, split=sep, fixed=TRUE), function(x) (x[1])))
covvars_possibly_long_format <- unique(covvars_possibly_long_format)
existence_check_covvars2 <- unlist(lapply(covvars_possibly_long_format, existence))
existenceerror(c(acevars_not_found,existence_check_covvars2))
covvarslong_checked <- covvars_possibly_long_format
} else {
covvarslong_checked <- NULL # if the condition is fulfilled, then all the covariates are in wide format and none in long
}
if (length(covvarswide_checked)==0) {
covvarswide_checked <- NULL
}
covvarsall <- c(covvarslong_checked,covvarswide_checked) # from now on: if a covariate ends with _1 or _2 -> it is wide!
suf1 <- paste0(sep,"1")
suf2 <- paste0(sep,"2")
covvars1 <- covvarswide_checked[grepl(suf1, covvarswide_checked)]
covvars2 <- covvarswide_checked[grepl(suf2, covvarswide_checked)]
covvarswide <- c(covvars1, covvars2)
} else if (is.null(covvars)) {
covvarsall <- NULL
covvars1 <- NULL
covvars2 <- NULL
covvarswide <- NULL
covvarslong_checked <- NULL
}
varswide1 <- c(acevars1,covvars1)
varswide2 <- c(acevars2,covvars2)
cat("\n\n\nACE Variables: \n\n")
print(acevarswide)
if (!is.null(covvarsall)) {
if (!is.null(covvarswide)) {
cat("\n\n\nThere are ",length(covvarswide)," wide-formatted covariates: \n\n")
print(covvarswide)
}
if (is.null(covvarswide)) {
cat("\n\n\nThere are not wide-formatted covariates\n\n")
}
if (!is.null(covvarslong_checked)) {
cat("\n\n\nThere are ",length(covvarslong_checked)," long-formatted covariates: \n\n")
print(covvarslong_checked)
}
if (is.null(covvarslong_checked)) {
cat("\n\n\nThere are not long-formatted covariates\n\n")
}
cat("\n\n\nThere are ",length(covvarsall),"covariates in total: \n\n")
print(covvarsall)
} else {
cat("\n\n\nThere are no covariates at all \n\n")
}
varswideonly <- c(acevarswide,covvarswide)
cat("\n\n\nThere are ", length(varswideonly), "wide-formatted Variables: \n\n")
print(varswideonly)
variables <- c(acevarswide,covvarsall)
cat(paste0("\n\n\nAll in all, there are ",length(variables)," variables: \n\n"))
print(variables)
rna <- function(x) replace(x, is.na(x), "")
checkvariance <- function(v1,v2) {
identicalcheck <- as.vector(colSums(ifelse(rna(data_orig[,v1, drop = FALSE])==rna(data_orig[,v2, drop = FALSE]), 0, 1)))
if (0 %in% identicalcheck == TRUE) {
ind <- identicalcheck==0
result1 <- v1[ind]
result2 <- v2[ind]
result <- c(result1,result2)
if (!is.null(result)) {
stop(c("The following acevars are identical and have no within-variance: ",paste(result, sep = " ", collapse = ", ")))
}
}
else {
cat("\n\n\nAll the wide-formatted variables have within-pair variance")
}
}
checkvariance(varswide1,varswide2)
usevariables <- c(variables,"zyg")
usedata <- subset(data, select = c(usevariables)) # Data set with only variables used for the model
cat("\n\n\nSummary total Data\n\n")
print(summary(usedata))
# Check if zygosity variable is coded correctly
if (min(data$zyg) != 1 & max(data$zyg) != 2) {
stop("Zygosity variable must be coded as follows: 1 = MZ, 2 = DZ. Please, recode the zygosity variable.")
}
# Starting Values
# Means Vector
# acevars
svmeanacevarswide1 <- colMeans(usedata[,acevars1, drop = FALSE], na.rm=TRUE)
svmeanacevarswide2 <- colMeans(usedata[,acevars2, drop = FALSE], na.rm=TRUE)
svmeanacevars <- rowMeans(cbind(svmeanacevarswide1, svmeanacevarswide2), na.rm=TRUE)
cat("\n\n\nStarting Values of the acevars for the mean vector\n\n")
print(svmeanacevars)
# covvars
# wide
if (!is.null(covvarswide)) {
svmeancovvarswide1 <- colMeans(usedata[,covvars1, drop = FALSE], na.rm=TRUE)
svmeancovvarswide2 <- colMeans(usedata[,covvars2, drop = FALSE], na.rm=TRUE)
svmeancovvarswide <- rowMeans(cbind(svmeancovvarswide1, svmeancovvarswide2), na.rm=TRUE)
} else {
svmeancovvarswide <- NULL
}
# long
if (!is.null(covvarslong_checked)) {
svmeancovvarslong <-  colMeans(usedata[,covvarslong_checked, drop = FALSE], na.rm=TRUE)
} else {
svmeancovvarslong <- NULL
}
# all
svmeancovvars <- c(svmeancovvarslong,svmeancovvarswide)
svmean <- c(svmeanacevars,svmeancovvars)
cat("\n\n\nStarting Values of the covvars for the mean vector\n\n")
if (!is.null(svmeancovvars)) {
print(svmeancovvars)
} else {
cat("There are no covariates")
}
cat("\n\n\nStarting Values for the mean vector\n\n")
print(svmean)
# Covariance Matrix of the covariates (at the moment the function uses default values)
if (!is.null(covvars)) {
# here comes the code ! :-)
# here something to begin with
# unname(as.matrix(cor(data[,covariates], use = "na.or.complete"))) # S matrix starting values for non-decomposed covariates
# svS <- round(unname(as.matrix(cov(data[,covariates], use = "na.or.complete"))),3) # S matrix starting values for non-decomposed covariates
# svS
}
# define the MZ and DZ data sets
mzData    <- subset(usedata, zyg==1, variables)
dzData    <- subset(usedata, zyg==2, variables)
cat("\n\n\nSummary MZ Data\n\n")
print(summary(mzData))
cat("\n\n\nSummary DZ Data\n\n")
print(summary(dzData))
# Shortcuts for the matrix dimensions
# No. of Variables
nv <- length(acevars) # Vars per twin
ntv <- nv*2 # Vars per twin pair
m <- (nv*2) # Decomposed manifest variables
c <- length(covvarsall) # Control variables
l <- 3*nv*2
t <- m+l+c
# Build elements to construct expected covariance matrix (RAM Notation)
# Matrix A
# Helper objects for object of manifest paths between acevars f
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathB <- lower.tri(mat)
freepathB
mat[upper.tri(mat, diag = TRUE)] <- 0
valuespathB <- mat
valuespathB
nvstring <- as.character(1:nv)
pathBlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("b",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathBlabel[upper.tri(pathBlabel, diag = TRUE)] <- NA
pathBlabel
pathB <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathB,
values = valuespathB,
labels = pathBlabel,
name = "b")
pathZ <- mxMatrix(type = "Zero", nrow = nv, ncol = nv, name = "pZ")
pathCov_label_variance <- function(string) {
stringend <- substring(string, nchar(string)) == "1"
if  (stringend == TRUE) {
c(paste0("b",string,1:nv),rep(NA,nv))
}
else {
c(rep(NA,nv),paste0("b",string,1:nv))
}
}
pathCovlabelvariance <- as.matrix(sapply(covvarswide,pathCov_label_variance))
if (length(pathCovlabelvariance)==0) {
pathCovlabelvariance <- NULL
}
pathCovvaluevariance <- pathCovlabelvariance
pathCovvaluevariance[!is.na(pathCovvaluevariance)] <- .3
pathCovvaluevariance[is.na(pathCovvaluevariance)] <- 0
mode(pathCovvaluevariance) <- "numeric"
pathCovfreevariance <- pathCovvaluevariance==.3
## Cov Vars without variances
pathCov_label_constant <- function(string) {
paste0("b",rep(paste0(string,1:nv),2),rep(c(1,2),each=nv))
}
pathCovlabelconstant <- as.matrix(sapply(covvarslong_checked,pathCov_label_constant))
if (length(pathCovlabelconstant)==0) {
pathCovlabelconstant <- NULL
}
pathCovvalueconstant <- pathCovlabelconstant
pathCovvalueconstant[!is.na(pathCovvalueconstant)] <- .3
pathCovvalueconstant[is.na(pathCovvalueconstant)] <- 0
mode(pathCovvalueconstant) <- "numeric"
pathCovfreeconstant <- pathCovvalueconstant==.3
pathCovlabel <- cbind(pathCovlabelconstant,pathCovlabelvariance)
pathCovvalue <- cbind(pathCovvalueconstant,pathCovvaluevariance)
pathCovfree <- cbind(pathCovfreeconstant,pathCovfreevariance)
pathCov <- mxMatrix(type = "Full", nrow = ntv, ncol = c, byrow = FALSE,
free = pathCovfree,
values = pathCovvalue,
labels = pathCovlabel,
name = "pCov")
mat <- matrix(0.3,nrow = nv,ncol = nv)
mat
freepathAC <- lower.tri(mat, diag = TRUE)
freepathAC
mat[upper.tri(mat, diag = FALSE)] <- 0
valuespathAC <- mat
valuespathAC
mat[lower.tri(mat, diag = FALSE)] <- 0
valuespathE <- mat
valuespathE
freepathE <- valuespathE == .3
freepathE
nvstring <- as.character(1:nv)
pathAlabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("a",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathAlabel[upper.tri(pathAlabel, diag = FALSE)] <- NA
pathAlabel
pathClabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("c",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathClabel[upper.tri(pathClabel, diag = FALSE)] <- NA
pathClabel
pathElabel <- matrix(apply(expand.grid(nvstring, nvstring), 1, function(x) paste("e",x[2], x[1], sep="")), nrow = nv, ncol = nv, byrow = TRUE)
pathElabel[upper.tri(pathClabel, diag = FALSE)] <- NA
pathElabel
pathA <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathAC,
values = valuespathAC,
labels = pathAlabel,
name = "a")
pathC <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathAC,
values = valuespathAC,
labels = pathClabel,
name = "c")
pathE <- mxMatrix(type = "Lower", nrow = nv, ncol = nv, byrow = TRUE,
free = freepathE,
values = valuespathE,
labels = pathElabel,
name = "e")
pathBottom <- mxMatrix(type = "Zero", nrow = l+c, ncol = t, name = "Bottom")
pathMan <- mxAlgebra(expression = cbind(rbind(cbind(b,pZ),
cbind(pZ,b)),pCov), name = "pM")
pathACE <- mxAlgebra(expression = rbind(cbind(a,c,e,pZ,pZ,pZ),
cbind(pZ,pZ,pZ,a,c,e)), name = "pACE")
matA <- mxAlgebra(expression = rbind(cbind(pM,pACE),
Bottom),
name = "A")
print(matA)
cat("\n\n\n... Bis hierhin läuft alles durch! Weiter geht's! :-)")
}
twinflex(acevars = c("kultkapjahre"), covvars = c("age"),data = data_orig,sep = "_",zyg = "zyg")
